\chapter{Background and Related Work}

\section{Overview}

In this chapter, the concepts and definitions which are needed to implement the proposed system are identified. In the first section, the tools and concepts used from relational database management system and in the second section, the concepts in Blockchain technology are introduced. The third section is also dedicated to discuss about the related work and the researches which have been done in this field and compare it with our proposed system.

\section{Temporal Databases}
Temporal database is any type of database that requires some aspect of time \cite {elmasri2010fundamentalsofdatabase}. Since historical records have a timestamp which indicates the time of a transaction occurrence, in the proposed system, temporal database is a way to store and manage historical records of the transactions.

%----------------------------------definition Temporal Database-----------------------------------------

\textbf {Definition 1. (Temporal Database)}:
Let $ r_i = \{r_1, r_2, ... , r_n \}$, be $n$ number of tables in the relational database $D$. Denote the attributes of each table as $attr(r_i)$. A temporal table denoted $r_i^T$ is a table with attributes $atr(r_i^T) = \{ (updated, deleted) \in \mathcal{T} \}\cup attr(r_i)$ where $\mathcal{T} = \{t_0,t_1,...,t_n\}$ is the time domain in which transactions on $r_i$ happened. A temporal database denoted $D^T$ is the result of augmenting $D$ by $r_i^T$:

\begin{center}
	{$D^T = D \cup \{{r_i^T}: r_i \in D \}$}
\end{center}

The temporal database $D^T$ contains the entire history of the records ever existed in $D$.

\textbf{Example 1.} Given a normal relational table $r_1$ (Table 2.1) and a temporal table $r_1^T$ (Table 2.2), the $attr(r_1) = (id, item, value)$ and $attr(r_1^T)= (id, item, value, updated, deleted)$. The result of query $q_1 = \sigma_{id = 22}(r_1)$ is $\{(22,Pencil,7.50\$)\}$ and the result of same query on the temporal table $q_2 = \sigma_{id = 22}(r_1^T)$ is $\{(22,pencil,8.0\$,2018-03-21,NULL),(22,pencil,7.50\$,2018-03-30,NULL)\}$. Also the query $q_3 = \sigma_{id = 21}(r_1)$ results in $NULL$ however, the same query on the temporal table $q_4 = \sigma_{id = 21}(r_1^T)$ has the history of record with id = 21: $\{(21,ruler,3.25,2018-02-10,NULL),(21,ruler,3.25,NULL,2018-02-20)\}$.
\begin{center}

\begin{table}[t]
	\centering
	\caption{Normal Relational Table $r_1$}
	\begin{tabular}{p{4cm}p{4cm}p{4cm}}
		\hline
		id & item      & value  \\ \hline
		22 & Pencil    & 7.50\$ \\
		23 & Notebook & 12.0\$   \\ \hline
	\end{tabular}
\end{table}

\begin{table}[t]
	\centering
	\caption{Temporal Table $r_1^T$}
	\begin{tabular}{p{1cm}p{2cm}p{3cm}p{3cm}p{2cm}}
		\hline
		id & item      & value  & updated  & deleted\\ \hline
		21 & Ruler    & 3.25\$  & 2018-02-10  &  - \\  
		21 & Ruler    & 3.25\$  & -  &  2018-02-20 \\
		22 & Pencil    & 8.0\$  & 2018-03-21  &  - \\
		22 & Pencil    & 7.50\$  & 2018-03-30  &  -\\
		23 & Notebook & 12.0\$  & 2018-04-01 & - \\ \hline
	\end{tabular}
\end{table} 
\end{center}

%---------------------------------- End of Definition Temporal Database -----------------
%---------------------------------- Defintion Time Domain -------------------------------
\textbf{Definition2. (Time domain)}: 
The time domain $\mathcal{T}$ consists of discrete timestamps $t_0,t_1,...,t_n$ in which transactions on tables $r_i \in D$ happened. the range of time domain is: $\mathcal{T} = [t_0, \infty)$ where $t_0$ is the timestamp in which the first record added to the table $r_i$.
The time domain of a temporal table $r_i^T \in D^T $ is calculated by:

\begin{center}
	$\mathcal{T} = r_i^T[updated] \cup r_i^T[deleted]$
\end{center}
For example in the temporal table $r_1^T$ (Table 2.2), the time domain is:
$\mathcal{T} = [2018-02-10,2018-04-01]$.
%---------------------------------- End of Definition Time Domain -----------------------
%---------------------------------- Defintion Timestamps --------------------------------

\textbf{Definition 3. (Timestamps)}: A timestamp $t_i \in \mathcal{T}$ is a particular position in the time domain, in which particular transaction(s) happened. For example in the temporal table $r_1^T$ (Table 2.2), ``2018-03-30'' is a timestamp in which the record with ``id = 22'' updated.
%---------------------------------- End of Definition Timestamps ------------------------
%---------------------------------- Defintion Timeline ----------------------------------

\textbf{Definition 4. (Timeline)}: Let $u_i(t_j)$ be the total transactions on the tables $r_i \in D$ at timestamps $t_j \in \mathcal{T}$, where $i,j=\{0,1,...,n\}$. The $u_i(t_j)$ could be represented as an ordered set points on a vector. This vector is called a timeline for the transactions happened on $r_i \in D$. Figure x illustrates the concept of timeline.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figs/timeline.pdf}
	\caption{Timeline.}
	\label{fig:timeline}
\end{figure}

%---------------------------------- End of Definition Timeline --------------------------
%---------------------------------- Defintion snapshot ----------------------------------
\textbf{Defionition 5. (Snapshot and snapshot-queries)}: Given a temporal table $r^T \in D^T$ and a timestamp $t \in \mathcal{T}$, we denote $s(t)$ to be the table instance that obtained by calculating the $\{max(r^T[m])|t : m\in r)\}-r^T[deleted]$ for $\mathcal{T}\leq t$. Note that $s(t) \in D^T$ but not necessarily $s(t) \in D$. A snapshot is a materialized version of $D(t) = \{s_1(t),s_2(t),...,s_n(t)\}$. A snapshot-query is an arbitrary relational query on $D(t)$.

We can construct the snapshots using simple windowing functions (as in supported
by PostgreSQL \cite{momjian2001postgresql}).

    \vspace{1em}
\begin{center}

{\small
	\begin{tabular}{|l|} \hline
		$\mathrm{snapshot}(r, t)$ = \\
		\verb|| \textsc{With} $T$ \textsc{as} ( \\
		\verb| | \textsc{select} id, $\{\mathrm{last\_value}(x) \mathrm{\ as\ } x:
		x\in attr(r)\}$ \textsc{over} $W$ \\
		\verb| | \textsc{from} $r^T$ \\
		\verb| | \textsc{where} updates $\leq t$ \\
		\verb| | \textsc{window} $W$ \textsc{as} 
		\textsc{partition by} id \textsc{order by} updates\\
		\verb|| ) \\
		\verb|| \textsc{select} id, $\{x: x\in attr(r)\}$ \textsc{from} $T$ \\
		\verb|| \textsc{where not} $T.$deleted \\ \hline
	\end{tabular}
}
\end{center}

The query $\mathrm{snapshot}(r, t)$ computes the snapshot of $r$ at timestamp
$t$ by applying the latest update of each tuple up to timestamp $t$, while
removing tuples that have been deleted.

%---------------------------------- End of Definition snapshot --------------------------


\section{Blockchain}
In a big picture, Blockchain technology is a distributed trusted public ledger that is tamper-proof and it is open to anyone to inspect \cite{OECD2016Science}. Although today there are a wide range of applications that are using Blockchain \cite{dhillon2017blockchain}, but ‌Blockchain is widely known for its application in cryptocurrencies such as Bitcoin \cite{nakamoto2008bitcoin}. As a matter of fact, Blockchain is the secret why cryptocurrencies are secure, work in a decentralized network, do not need any central verification system and the users in the system are anonymous \cite{halaburda2016beyond}.
While there are many functionalities within a Blockchain system, such as user anonymity, being public and no need for a central verification system, in this project, for the sake of confidentiality and transparency, not all functionalities within the Blockchain is employed. To understand how Blockchain has been utilized in the proposed system, there are some definitions which needs to be discussed about.

%---------------------------------- Begin of Definition cryptography --------------------------
\textbf{Definition.(Cryptography)}:
Cryptography is a way of secure communication between parties in a network while adversaries might also be present. Using Cryptography, messages sent or received are encrypted so that the adversaries cannot read the normal form of the message. This communication is established through various steps such as cryptographic key assignment, encryption and decryption of messages or digitally signing a message and verifying the digital signatures \cite{stallings2017cryptography}.
%---------------------------------- End of Definition cryptography ----------------------------
%----------------------------- Begin of Definition cryptographic keys -------------------------

\textbf{Definition.(Cryptographic Keys)}: Let $u$ be the authenticated user who is using database $D$. By the creation of the profile of $u$ in the system, a set of strings $<K_{priv},K_{pub}> \in \mathbf{N}^+$ is generated and assigned to the user where $K_{pub}$ is the public key that is accessible to everyone on the system, and $K_{priv}$ is the private key that is known only to $u$. These keys are used to encrypt/decrypt messages which is transmitted between the users\cite{stallings2017cryptography}.

%----------------------------- End of Definition cryptographic keys -------------------------
%----------------------------- Begin of Definition Assymetric Encryption --------------------
\textbf{Definition.(Assymetric Encryption)}: Let $E$ be the encryption algorithm, $D$ be the decryption algorithm, $m$ be the message which needs to be encrypted and $c$ be the encrypted message. Given the cryptographic keys $<K_{pub}, K_{priv}>$, An encryption technique is said to be asymmetric if:

\begin{center}
	$c = E(K_{pub},m)$ and  $m = D(K_{priv},c)$
\end{center}
or
\begin{center}
	$c = E(K_{priv},m)$ and  $m = D(K_{pub},c)$
\end{center}
Therefore:
\begin{center}
	$D(E(m,K_{pub}),K_{priv}) = m$ 
\end{center}
and
\begin{center}
	$D(E(m,K_{priv}),K_{pub}) = m$
\end{center}
Note that, if $K_{pub}$ is known, and $E(K_{pub},m)$ is also known, in asymmetric encryption method, it is impossible to get $m$ without $K_{priv}$ \cite{stallings2017cryptography}.

Figure \ref{fig:AssymmetricEncryption} shows the basic steps to send and receive messages between two parties in a secure way by utilizing asymmetric encryption technique. In this scenario, the sender has access to the recipient's public key only. The sender encrypts the document which is to be transferred by using the recipients public key. In asymmetric technique, the only way to decrypt the document is to use the recipient's private key which the is only known to the recipient. This is a powerful technique to ensure that the adversaries cannot read the document in the middle of the connection.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figs/asymmetricEncryption.pdf}
	\caption{Asymmetric Encryption Technique.}
	\label{fig:AssymmetricEncryption}
\end{figure}
%----------------------------- End of Definition Assymetric Encryption --------------------
%----------------------------- Begin of Definition Hash function --------------------------
\textbf{Definition. (Hash function)}: Assume $m \in \mathcal{A}$ to be the message with an arbitrary size chosen from domain $\mathcal{A}$. $hash(m)\rightarrow sketch$ 
is a function that maps the $m$ of any size from domain $\mathcal{A}$ to a fixed size string (normally 256 bits) in a smaller domain $\mathcal{B}$ \cite{aumasson2014thehash}.
%----------------------------- End of Definition Hash function ----------------------------
%----------------------------- Begin of Definition Digital Signature ----------------------

\textbf{Definition. (Digital Signature)}: Digital signature is used to ensure that the digitally transfered data has not been altered while transferring. Also it verifies whether or not the transfered data was submitted by a recognized source \cite{katz2010digital}.\\
Let $m$ be the document which needs to be digitally signed and transfered. Denote $h$ as hash function, $E$ as encryption algorithm and $D$ as decryption algorithm. In order to digitally sign a document and verify a signature, following steps should be taken:
\begin{itemize}
	\item \textbf{Step 1.} $H_r = h(m)$
	\item \textbf{Step 2.} $S = E(H_r,K_{priv})$
	\item \textbf{Step 3.} $m$ and $S$ are sent
\end{itemize}
In order to verify:
\begin{itemize}
	\item \textbf{Step 1.} $m$ and $S$ are received
	\item \textbf{Step 2.} $H_t = h(m)$ is calculated
	\item \textbf{Step 3.} $H_r = D(S,K_{priv})$ is obtained
	\item \textbf{Step 4.} $m$ is valid if $H_t = H_r$ and invalid otherwise.
\end{itemize}
Figure \ref{fig:DigitalSignature} depicts the steps that needs to be taken for digitally sign a document and verifying a digital signature.\\
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figs/digital_signature.pdf}
	\caption{Digital Signature Creation and Verification.}
	\label{fig:DigitalSignature}
\end{figure}
%----------------------------- End of Definition Digital Signature ----------------------------
%------------------------------------- Defintion Blockchain -----------------------------------
\textbf{Definition. (Blockchain for This Project)}: Let $rec_i$ be the records stored in $r_i^T$. We denot $Sign$ as $S_r(attr(r_i^T$ for $rec_i))$ which is digital signature of attributes of $rec_i$. We can create a blockchain of historical records by storing the signature of previous record as an attribute of current record. The idea of the Blockchain has been depicted in figure \ref{fig:Blockchain}.

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{figs/blockchain.pdf}
	\caption{Idea of the Blockchain for the proposed system.}
	\label{fig:Blockchain}
\end{figure}

\section {Related Work}
There has been a wide range of studies on ensuring the trustworthiness of records in a database from different perspectives. These studies ranges from establishing trust between nodes in a real-time distributed systems \cite{khayat2017trust} to secret sharing schemes in cloud databases \cite{dutta2013privacy} and utilizing logfiles for forensic purposes \cite{sinha2014continuous}. In this project, the assumption is that the preventive models are not able to stop the advarsaries from manipulating the data of a relational database system, therefore a tamper-evident log table has been offered to evaluate whether or not the data has been altered. 

Database audit logs contain valuable information such as any insertion, deletion and modification of the records performed in a database along with the timestamp of the performed tasks. The United States department of defense in its “Trusted Computer System Evaluation Criteria” document and under requirement 4 pointed out the importance of auditing the transactions in a computer system in a secure and efficient manner \cite{USDoD1985}. In this document also protecting the audit logs from modification or destruction has been stressed out. ”ISO/IEC 27001” standard published by International Organization for Standardization and International Electrotechnical Commission \cite{ISOIEC27001}, “Guide to Computer Security Log Management” standard published by United States National Institute of Standard and Technology \cite{NIST2006}, eHealth Ontario's HER standard \cite{ehealth3542}, European Commission Information System Security Policy C(2006) 3602 \cite{EC2006} and the University of British Columbia's information Security Standard {\#}17 \cite{UBC2014} are a few of many other international or domestic regulations that have suggested guidelines to secure computer systems by using historical records such as audit logs.

Analyzing audit logs for forensic purposes has been the topic of research by many scientists however, since the trustworthiness of the results from log table analysis has a direct relationship with the authenticity of the records of the log file, a lot of studies have been carried out to make log tables tamper-proof. Haber {\it et al.}\cite{haber1991how} proposed a basic methodology by utilizing timestamping and hash chains in order to make unmodifiable historical records for digital documents. Peha in \cite{peha1999electronic}, offered a mthod to detect log tampering by one way hashing and employing multiple trusted notaries to keep track of all transactions. The author argued that if any notary decided to falsify the transaction, the attempt is discovered by other notaries. Snodgrass {\it et al.} \cite{snodgrass2004Tamper} also offered one way hashing mechanism and employed trusted notaries, however in order to enhance the security of the method offered by Peha, they offered to hash the records with a timestamp of previous transaction modification. Schneier {\it et al.}\cite{schneier1998cryptoraphic} offered a cryptographic-based mechanism to create hash chains and make the log files nearly impossible for the attacker to alter. The validity of the transactions was also done by trusted third-parties who have the cryptographic keys.

Although the afformentioned researches might have promising results to protect the historical records from being compromised by an outsider, but they have one thing in common which is the role of an insider to carry out malicious attacks is forgotten. Also hiring third-party software/hardware may bring up a lot of privacy concerns. Therefore, unlike the mentioned works, not only our proposed system doesnot require a third-party notary to attest the authenticity but also it doesnot put trust on any user of the system.

The role of privileged users in acting maliciousely in a database has been discussed by many researchers \cite{crosby2009tamper-evident} \cite{wagner2018detect}. Liu {\it et al.} offered a network-based auditing mechansim which also keeps track of privileged users' activity and performs audit analysis through event correlation. Wagner {\it et al.} \cite{wanger2017carving} proposed a mechanism to detect database file tampering by looking for inconsistencies in the database's storage. The authors argued that the databases follow patterns in storage which even the privilaged users have no access to. Therefore, if a record is deleted maliciousely in the log file, the inconsistency in the storage is evident for a period of time. Unlike mentioned propsed methods, our system uses inherent to RDBMS tools and doesnot require a network-level-auditing mechansim or having access to the server's storages, therefore it could be easily implemented on remote servers and relational databases on cloud storages. Also, our proposed system not only discovers maliciousely deletion of the records but also identifies any malicious modification without any time constraints.

For the sake of gathering verifiable evidences, in our proposed system, any changes to the database regardless of the users' access privilages needs to be tracked. This action needs to be done by utilizing inherent to DBMS tools. Fabbri {\it et al.} \cite{fabbri2013select} discussed about SELECT triggers, required database spicifications, efficient implementation techniques and their role for data auditing. Hauger {\it et al.}\cite{hauger2014information} also discussed about using the triggers in the database for forensic purposes. Triggers are supported by RDBMS and they are good candiates to be used in the proposed system but it is naive to assume that a simple trigger is secure enough to be used for forensic purposes therefore our proposed system uses Blockchain to make a chain of transactions that are captured by database triggers.

The first attempt to use chained hashes for securing data from tampering is known to be done by Haber {\it et al.} \cite{haber1991how} where the authors proposed a methodology to securely timestamp the digital files and create digital signatures and hash chains. This work was then improved by Schneier {\it et al.} \cite{schneier1998cryptoraphic} \cite{schneier1999minimizing} \cite{schneier1999secure} by offering to exchange secret codes with a trusted third party who is able to verify the autheticity of the chain. They offered a method to change the shared secret as new transaction occurs, therefore since the attackers do not have the previous secret codes, it is impossible for them to alter any records which was previousely added. Our proposed method is similar to the mentioned works in the sense that our historical records are chained together using the digital signatures, however we use asymmetric encryption without the need of a third-party to attest the authenticity of the transactions.
